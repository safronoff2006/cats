import cats.data.EitherT
import cats.effect.{IO, Sync}
import cats.effect.unsafe.implicits._
import cats.implicits._
import cats.mtl._
import cats.mtl.implicits._

import java.util.Date

object Main extends App {

  println("Изучаем Cats!".toUpperCase)
  println("Functional error handling with monads, monad transformers and Cats MTL")

  // MTL is an acronym and stands for Monad Transformer Library.
  // Its main purpose is to make it easier to work with nested monad transformers.
  // It achieves this by encoding the effects of most common monad transformers as type classes.

  // Cats MTL
  // Provides transformer typeclasses for cats' Monads, Applicatives and Functors.
  // You can have multiple cats-mtl transformer typeclasses in scope at once without implicit ambiguity,
  // unlike in pre-1.0.0 cats or Scalaz 7.

  // Функциональная обработка ошибок с помощью монад, преобразователей монад и Cats MTL

  // То, как мы справляемся с неудачами в большинстве приложений ООП,
  // само по себе является распространенным источником неожиданного поведения.
  // Я считаю, что исключения и try/catch операторы используются слишком часто.
  // В большинстве случаев неочевидно, что метод может выдать и когда.
  // Крайние случаи следует рассматривать с такой же осторожностью, если не с большей,
  // чем остальной код, однако они становятся невидимыми благодаря механизмам обработки ошибок,
  // которые скрывают неудачи вместо того, чтобы выделять их.

  // В этой записи блога я продемонстрирую некоторые методы функционального программирования,
  // а именно монады, преобразователи монад и Cats MTL, которые могут помочь вам справиться с неудачами таким образом,
  // чтобы они были четко видны.
  // Я также расскажу о разделении технических неудач и пограничных случаев бизнеса,
  // чтобы сохранить бизнес-логику там, где ей и место:
  // в самом сердце вашего программного обеспечения.
  // Предварительное знание вышеупомянутых концепций не требуется,
  // поскольку я попытаюсь определить их по ходу дела.
  // Однако имейте в виду, что эти определения не являются ни исчерпывающими, ни самыми строгими.
  // Существует столько же способов объяснить монады, сколько и вариантов их использования,
  // обработка ошибок — лишь один из них.
  // Для более широкого определения монад я рекомендую эту статью Матеуша Кубушока.
  // https://kubuszok.com/2018/different-ways-to-understand-a-monad/#monad

  // Эта статья по сути является более углубленной версией доклада о Cats MTL,
  // который я сделал на Typelevel Summit 2020.
  // Если вы ищете более сжатое введение в монадные трансформаторы и функциональную обработку ошибок,
  // рассмотрите возможность просмотра доклада.
/*
  План

  Проблемы с исключениями
  Возвращение исключительности исключений
  Монады, краткое и, вероятно, несовершенное определение
  Монады IO, почему нас это волнует?
  Обработка ошибок с использованием Cats Effect IO
  Моделирование потока аутентификации
  Ошибки как граждан вашего домена
  Трудность объединения эффектов (почему монады не объединяются)
  Комбинирование эффектов с помощью монадных трансформаторов
  Короткое отступление: классы типов и полиморфизм ad hoc
  Знакомство с кошками MTL Монады, краткое и, вероятно, несовершенное определение
  Заключительные примеры и заключение
  */


  object part1 {

    //////используемые типы
    sealed case class User(name: String)
    sealed case class Account(id: String, user: User )
    sealed case class Album(name: String)
    sealed case class Track(name: String)
    //////////

    def chapter1: Unit = {
      // Проблемы с исключениями

      // В объектно-ориентированном программировании принято обрабатывать ошибки с помощью исключений и try/catch операторов.
      // То, как они работают, знакомо большинству разработчиков: что-то идет не так, вы throwсоздаете объект,
      // представляющий проблему, и этот объект будет распространяться по всему стеку вызовов,
      // пока не catch будет достигнут блок или приложение не завершит работу.

      // Этот механизм удобен и позволяет легко реализовать распространенные стратегии обработки ошибок:

      // - То, как методы могут выбирать catch исключение или эскалировать его, формирует цепочку делегирования,
      // в которой контролирующие методы несут ответственность за ошибки своих подчиненных.
      // В некотором смысле исключения имитируют поведение иерархий, которые мы можем найти вокруг себя.
      // Как и многие концепции ООП, они на первый взгляд кажутся более простыми для понимания в сравнении с реальным миром.
      // - Тот факт, что неперехваченное исключение в конечном итоге завершит работу приложения,
      // означает, что реализовать фатальные исключения легко: просто дайте им работать свободно.
      // Это, конечно, намного удобнее, чем явно вызывать, exit когда это нужно. Верно?

      // Но это удобство не компенсирует риски и умственные издержки, которые производят исключения.
      // При чрезмерном использовании исключения вносят сложность и потенциальные ошибки в кодовую базу,
      // которые все происходят из-за этого единственного недостатка: исключения невидимы.

      // Когда вы смотрите на сигнатуру метода, вы не можете знать наверняка,
      // может ли он потерпеть неудачу и при каких обстоятельствах.
      // Аннотирование метода комментарием, который говорит «будьте осторожны, это может вызвать эти исключения»,
      // считается лучшей практикой во многих языках, и в некоторых есть общепринятый способ сделать это, как @throws в Java.
      // Но мы все были свидетелями методов,которые бросались в производство без какого-либо предварительного
      // уведомления или с аннотациями, которые лгали нам в лицо.
      // В конце концов, компилятор не заставляет меня говорить правду в комментариях,
      // это делает только надлежащий обзор кода.
      // Люди не успевают, становятся небрежными, забывают комментарии здесь и там,
      // и вот вам: неперехваченное исключение в производстве.

      // Зачастую бизнес-логика добавляется по мере развития программного обеспечения,
      // не все должным образом информированы, устаревшая документация остается.

      /**
       * This never throws, trust me.
       */
      def computeDiscountedPrice(originalPrice: Float, discountPercent: Float) = {
        if (discountPercent > 75) {
          // If you're going to document errors poorly,
          // you might as well make sure your messages are cryptic and unhelpful
          throw new RuntimeException("Can't apply discount")
        } else {
          originalPrice - (originalPrice * discountPercent / 100)
        }

        // Фактически, единственный способ узнать наверняка обстоятельства, при которых метод может выдать исключение,
        // — это рекурсивно проверить его реализацию и реализацию всех методов в нем.
        // Надеюсь, вы можете почувствовать, какие нелепые умственные издержки это вносит, особенно в больших кодовых базах.
        // Когда я реализую функцию, я должен иметь возможность понять существующий код,
        // глядя на него, и доверять тому, на что я смотрю.
        // Я должен иметь возможность делать это, не опасаясь неизвестных пограничных случаев и необъявленных побочных эффектов,
        // подкрадывающихся за моей спиной.

        // Для меня это одна из главных причин, по которой функциональное программирование так привлекательно.
        // ФП, помимо прочего, заключается в доверии к тому, что вы видите.
        // Хотя точное определение функционального программирования все еще является предметом некоторых споров,
        // одной из устоявшихся характеристик является максимизация использования функций в математическом смысле.

        // Эти функции:
        // - ссылочно прозрачны или не имеют побочных эффектов , что означает,
        // что они только связывают некоторые входные данные с некоторыми выходными данными,
        // т. е. они не делают ничего, кроме того, что указано в их сигнатуре
        // - в целом, что означает, что они определены для всего набора аргументов, которые они могут получить,
        // т.е. они не делают ничего меньше, чем объявлено

        // В совокупности эти характеристики гарантируют, что вы сможете быстро понять имеющийся код
        // и с уверенностью выполнить его рефакторинг.

        // Итак, очевидно, что методы, которые выбрасывают исключения, не подходят под это определение.
        // Выбрасывание исключений обычно означает неудачу на определенном подмножестве аргументов
        // или при определенных обстоятельствах, что нарушает правило тотальности.
        // Нам нужен другой способ моделирования ошибок, и я считаю, что разочарование,
        // вызванное традиционными шаблонами обработки ошибок, само по себе достаточно,
        // чтобы мотивировать изучение чего-то совершенно иного.

        //  Итак, если не исключения, то что тогда?

    }
  }

    def chapter2 = {
      // Возвращение исключительности исключений

      // Чтобы сделать невидимые ошибки снова видимыми, нам нужно перестать кодировать их как исключения
      // и начать кодировать их как обычные данные.
      // Нам нужен способ продемонстрировать случаи ошибок наших методов непосредственно в их сигнатурах,
      // чтобы они больше никого не удивляли, и нам нужен способ безопасного составления подверженного ошибкам кода,
      // потому что мы не пишем все наше приложение в одной функции, верно?

      // Один из способов, которым мы можем превратить ошибки в данные,
      // это использовать Option для моделирования потенциального отсутствия ценности и Either для моделирования вычислений,
      // которые могут дать сбой, связывая дополнительные данные с сбоем.
      // Я представлю несколько примеров использования этих структур для обработки ошибок,
      // но не буду останавливаться на них слишком долго,

      // Давайте вернемся к нашему первому примеру. Если бы мы хотели отказать пользователю в скидке в определенных случаях,
      // вместо того, чтобы выдавать исключение, мы могли бы расширить возвращаемый тип нашей функции,
      // используя Option вместо этого.

      /**
       * This never throws, for real this time.
       */
      def computeDiscountedPrice(originalPrice: Float, discountPercent: Float): Option[Float] = {
        if (discountPercent > 75) None
        else Some(originalPrice - (originalPrice * discountPercent / 100))
      }

      // На этот раз функция никогда не выдает исключение.
      // Вместо этого она возвращает тип данных, который кодирует необязательность,
      // оставляя вызывающему объекту ответственность за обработку каждого возможного случая
      // (и если он этого не сделает, компилятор выдаст предупреждение)

      val validDiscount = computeDiscountedPrice(999.95F, 20.0F)    // Some(799.9600219726562)
      val invalidDiscount = computeDiscountedPrice(999.95F, 77.00F) // None

      // Отлично! Больше никаких исключений, взрывающихся у нас на глазах.
      // Теперь я знаю, что иногда это может давать сбой, и я соответствующим образом адаптирую свой код.
      // Но в каких именно обстоятельствах? Option не дает нам никаких подробностей о том,
      // почему отсутствует значение, оно просто есть, с этим надо разбираться.
      // В некоторых случаях желательно передать дополнительную информацию о природе ошибки.
      // В таких ситуациях использование Either вместо этого позволяет нам давать сбой с определенным значением,
      // как показано в следующем примере:


      def computeDiscountedPriceE(originalPrice: Float, discountPercent: Float): Either[String, Float] = {
        if (discountPercent > 75) Left("The discount cannot exceed 75%, that would ruin us!")
        else Right(originalPrice - (originalPrice * discountPercent / 100))
      }

      val validDiscountE = computeDiscountedPriceE(999.95F, 20.0F)
      // Right(799.9600219726562)
      val invalidDiscountE = computeDiscountedPriceE(999.95F, 77.00F)
      // Left(The discount cannot exceed 75%, that would ruin us!)

      // Когда мы хотим обеспечить выполнение определенного условия, есть еще более короткий способ сделать это:

      def computeDiscountedPriceE2(originalPrice: Float, discountPercent: Float): Either[String, Float] =
        // Either.cond requires a boolean
        Either.cond(
          discountPercent <= 75,
          // When true, return this wrapped in a Right
          originalPrice - (originalPrice * discountPercent / 100),
          // When false, return this on the left side instead
          "The discount cannot exceed 75%, that would ruin us!"
        )

      // Обратите внимание, что я выбрал a String в качестве типа ошибки слева, но я мог бы выбрать любой другой тип.
      // На практике я бы возражал против использования слева String и вместо этого использовал бы запечатанный тип,
      // что я и сделаю в дальнейших примерах. Для этого есть две основные причины:

      // - Во-первых, нет способа обеспечить исчерпывающую проверку при сопоставлении со строками.
      // Это означает, что компилятор сможет определить, когда вы не обработали ни одной ошибки ,но не то, что вы не обработали все ошибки.
      // Запечатанные типы обеспечивают вам эту дополнительную безопасность.

      // - Во-вторых, помните, как мне нравится, когда моя сигнатура функции говорит как можно больше?
      // Ну, в этом случае я знаю, что метод может завершиться ошибкой с сообщением,
      // что, безусловно, является улучшением, но поскольку a String — очень универсальная структура,
      // мне все равно придется смотреть на реализацию, чтобы узнать, каким может быть это сообщение.
      // Если я использую тип, специально созданный для моделирования пограничных случаев моей области,
      // само имя типа может многое мне рассказать о природе ошибки.
      // Позвольте вашим типам рассказать историю, и реализации будут очевидны.


    }

    def chapter3 = {
      // Монады, краткое и, вероятно, несовершенное определение

      // Существует множество хороших введений в монады, поэтому я не буду претендовать на самое подробное объяснение,
      // но я дам кое-что, над чем мы можем поработать в оставшейся части этой статьи.

      // Option и Either, которые мы использовали ранее, являются членами семейства структур, называемых монадами,
      // которые определяются общей формой и некоторыми законами.

      // Вообще говоря, для монады M значение типа M[A] представляет собой вычисление одного или нескольких значений типа A,
      // обернутых в контекст монады M.
      // Сама монада состоит из:

      // - конструктор типа, который позволяет нам создавать значения типа M[A] из простых значений типа A.
      // В Cats этот конструктор называется pure.

      // - функция, которая разворачивает монадические значения типа M[M[A]] в значения типа M[A]. Это называется flatten.

      // - аппликативный функтор, который предоставляет монаде:
      // --- функция map, которая позволяет нам преобразовать монадическое значение M[A] в  M[B],
      // применяя некоторую функцию A => B
      // --- функция ap, преобразующая монадическое значение путем применения функции M[A => B],
      // которая сама по себе заключена в монадический контекст
      // - некоторые законы, называемые идентичностями, которые я не буду здесь рассматривать

      // У Cats есть очень хорошее объяснение аппликационных функторов, которое я не буду здесь пытаться воссоздать.
      // https://typelevel.org/cats/typeclasses/applicative.html#what-is-ap

      // Однако в большинстве случаев монады определяются с помощью своего flatMap оператора,
      // а не с помощью комбинации flatten и map.
      // flatMap Оператор, который использует >>=инфиксную нотацию во многих языках,
      // позволяет нам преобразовывать монадическое значение, применяя функцию от простого значения к монадическому.
      // Он имеет следующую сигнатуру:

      def flatMap[F[_], A, B](monad: F[A])(fn: A => F[B]): F[B]  = ???

      // Оператор flatMap часто рассматривается как сущность монады.
      // Его также называют оператором композиции, потому что он позволяет нам объединять зависимые вычисления вместе:
      // если у меня есть некоторое монадическое значение F[A], функция формы A => F[B] и функция формы B => F[C],
      // то FlatMap позволяет мне скомпоновать их в этом порядке, чтобы получить конечное значение типа F[C],
      // что очень похоже на традиционную композицию функций (которую Scala выражает с помощью операторов andThen и compose).

      // Давайте посмотрим, как это определение монады применяется к Option структуре данных:
      // - Параметры имеют конструктор типа от A до Option[A], который называется Some



      val andy = User("Andy")

      val account: Option[Account] = Some(Account(id = "1234", user = andy))

      // У них есть map функция (стандартная библиотека Scala не определяет ap функцию,
      // но Cats может сделать это за нас):
      val user: Option[User] = account.map(_.user)

      // И у них есть flatMap функция:
      def getFavoriteAlbum(user: User): Option[Album] = Some(Album("бла"))
      val favoriteAlbum: Option[Album] = user.flatMap(getFavoriteAlbum)

      //Используя возможности монады, мы можем объединять зависимые вычисления в цепочку для решения более крупных задач
      // из более мелких, подобно тому, как мы используем функциональную композицию для разбиения сложных функций на более мелкие.

      def getUser(account: Account): User = andy
      def getFavoriteAlbumO(user: User): Option[Album] = Some(Album("альбом бла"))
      def getHiddenTrackO(album: Album): Option[Track] = Some(Track("трэк бла"))
      def getLyrics(track: Track): String = "На недельку,  до второго.."

      val lyrics: Option[String] =
        account
          .map(getUser)              // Some(User(Andy))
          .flatMap(getFavoriteAlbumO) // Some(Album(Abbey Road))
          .flatMap(getHiddenTrackO)   // Some(Track(Her Majesty))
          .map(getLyrics)
      // "Her Majesty's a pretty nice girl But she doesn't have a lot to say ..."

      // Наконец, поскольку монады в Scala используют flatMap оператор, имеющий особое значение в языке,
      // эта монадическая композиция, как и любая другая, может быть выражена с помощью for-comprehension,
      // что делает монадическую композицию более похожей на императивное программирование
      // и в некоторых случаях может значительно упростить код.

      def getAccount = account

      val lyrics2: Option[String] = for {
        acc <- getAccount
        user = getUser(acc)
        album <- getFavoriteAlbumO(user)
        track <- getHiddenTrackO(album)
      } yield getLyrics(track)



    }

    def chapter4 = {
      // Монады кодируют некоторый эффект

      // До сих пор мы рассмотрели (в некоторой степени), что такое монады, но не то, для чего они нужны,
      // и вам может быть любопытно, зачем они нам нужны; позвольте мне объяснить.
      // Монады для обогащения вычисления некоторым эффектом, некоторым дополнительным поведением,
      // специфичным для рассматриваемой монады.
      // Этот эффект кодируется на уровне типа, что означает, что, хотя тип A представляет набор вычисляемых значений,
      // тип M[A] представляет вычисляемые значения вместе с их связанным эффектом.
      // Любой фрагмент кода, который хотел бы взаимодействовать с монадическим значением, M[A]
      // должен был бы как-то иметь дело с этим эффектом.

      // Природа эффекта, кодируемого монадой, M специфична для этой монады:

      // - Option кодирует эффект необязательности
      // - Either кодирует эффект неудачи
      // - IO, как мы рассмотрим более подробно, кодирует эффект изоляции побочных эффектов
      // - Reader/ Kleisli кодирует эффект доступа к значениям из среды и передает эту среду через вычисления

      // Монады позволяют нам выражать общие вычислительные проблемы, не нарушая чистоту наших функций:
      // например, Option позволяют нам выражать отсутствие значения, не обращаясь к типам, допускающим значение null,
      // Either позволяют нам выражать неудачу, не прибегая к исключениям.
      // Поскольку эти эффекты кодируются на уровне типа,
      // компилятор может заставить нас обрабатывать их соответствующим образом, делая код более безопасным.
      // Например, вы можете скомпоновать Either вместе, чтобы построить сложную программу,
      // и обработать все возможные случаи ошибок в конце, так что ваша программа никогда не даст сбой во время выполнения.
      // (Это если вы не развернете структуру преждевременно, используя небезопасный метод, такой как .get)

      // Первая ошибка побеждает

      // Что означает использование монад в контексте управления ошибками?
      // Марк Канлас в докладе под названием «Функциональная обработка ошибок с помощью Cats»,
      // который я настоятельно рекомендую, использовал идею счастливого пути и грустного пути
      // для описания возможностей монад по замыканию.
      // https://www.youtube.com/watch?v=KQZjOJjnHIE

      // Идея заключается в том, что когда вы компонуете Option вместе,
      // конечное значение будет a Some только в том случае, если все базовые вычисления дадут a Some.
      // Если любой из компонуемых Option s даст a None, конечное значение будет None.
      // Композиция замкнется при первой обнаруженной ошибке, то есть любые дорогостоящие вычисления после того,
      // как None будет возвращено первое, вообще не будут оцениваться.

      // То же самое касается Either, который вернет либо самый последний Right,
      // либо самый первый Left, и для Try, другой монады с возможностями обработки ошибок.
      // Для монад имеет смысл закоротить вычисления таким образом,
      // поскольку монады используются для цепочки зависимых вычислений:
      // нет способа оценить одну часть композиции без значения из предыдущих частей.

      // Подводя итог:

      // Чистые функции простых значений, такие как A => B являются простейшими строительными блоками,
      // которые вы можете использовать для составления программы: их легко понять, они предсказуемы и они композируются.
      // Однако иногда их недостаточно. Когда нам нужно обогатить вычисление дополнительным поведением,
      // нам нужно использовать типы, которые не только кодируют значения, но и их связанные эффекты

      // Монады M[A] позволяют нам обогатить вычисление значений типа A некоторыми функциональными эффектами,
      // такими как необязательность, неудача, недетерминированность, асинхронность…
      // Природа этого эффекта зависит от конкретной рассматриваемой монады.
      // Суть монады заключается в способности объединять зависимые вычисления в цепочку
      // для формирования одного большего вычисления с помощью flatMap оператора, также записываемого как >>=

      // Еще одним ключевым свойством монад является короткое замыкание:
      // при использовании монад для обработки ошибок помните, что первая ошибка всегда побеждает.







    }

    def chapter5 = {
      // Монады IO, почему нас это волнует?

      // Итак, монады кодируют некий функциональный эффект.
      // IO Монада, реализацию которой вы можете найти в библиотеке Cats Effect,
      // является еще одним членом этого большого семейства, нацеленным на кодирование побочных эффектов и асинхронности.
      // Рассмотрим следующую сигнатуру:

      def getUser(id: String): IO[User] = ???

      // Значение типа IO[User] — это представление вероятно нечистой программы,
      // которая была превращена в ссылочно прозрачное значение путем приостановки ее выполнения.
      // Или, говоря иначе, это значение, представляющее программу, которая будет работать неопределенное время,
      // вероятно, будет иметь некоторые побочные эффекты, такие как подключение к внешней службе,
      // и в конечном итоге вернет значение типа User.
      // В отличие от Scala Future, это не дескриптор вычисления, работающего в другом потоке,
      // а просто план программы, ожидающей явного запуска.

      // Поскольку они приостанавливают побочные эффекты, IO s можно передавать свободно и без риска.
      // При их сцеплении, flatMap как если бы вы использовали любую монаду,
      // полученная композиция сама по себе является ленивым представлением.
      // Вся программа не будет запущена, пока вы не вызовете что-то подобное unsafeRunSync для нее.
      // Побочные эффекты в конечном итоге будут запущены, конечно, но, по крайней мере, не без вашего явного согласия.

      val a = IO(println("- Hello there"))
      val b = IO(println("- General Kenobi!"))

      // Nothing gets printed yet

      (a >> b).unsafeRunSync()
      // - Hello there
      // - General Kenobi!

      // Среди функциональных программистов ведутся споры о том, действительно ли монады IO делают нечистый код чистым.
      // На чьей вы стороне, на самом деле, вопрос определения.
      // Даже при работе с IO ваши побочные эффекты не исчезнут волшебным образом, они в конечном итоге будут запущены.
      // Можно сказать, ради точности, что монады IO являются чистыми вплоть до выполнения,
      // т. е. они являются чистыми представлениями нечистых программ, которые теряют свою чистоту, когда вы их запускаете.
      // Но, конечно, вы собираетесь запустить их в какой-то момент,
      // поэтому это различие не имеет большого значения, когда вы просто хотите отправить качественный код в производство.

      // Одна вещь, которая нравится как теоретикам, так и хакерам, заключается в том, что IO раскрывает наличие побочных эффектов.
      // Использование IO похоже на выделение опасного кода с помощью типов:
      // недетерминированные части вашего приложения четко отделены от остального,
      // призывая авторов и рецензентов к большей осторожности. Это свойство называется отслеживанием эффектов.
      // К сожалению, в нечистом языке, таком как Scala, отслеживание эффектов работает только в том случае,
      // если все остальные функции считаются чистыми по соглашению, компилятор не может его принудительно применять.
      // Полагаться на типы для отслеживания эффектов, моделирования ошибок и предотвращения невозможных состояний —
      // это здорово и снимет большую часть умственного напряжения, но это работает лучше всего,
      // когда все стремятся к чистым функциям; напоминание о том, что поставка хорошего кода — это командная работа.

      // Обработка ошибок с использованием ввода-вывода Cats Effect

      // Эффект IO из Cats Effect, а также некоторые другие реализации,
      // позволяют пользователям вызывать экземпляры Throwable внутри IO контекста,
      // распространять их по цепочке IO при составлении и восстанавливать их в какой-то момент,
      // так же, как вы использовали бы традиционные throw операторы.

      object logger {
        def error(msg: String, e: Throwable): Unit = println(msg, e.getMessage)
      }

      val failedIO: IO[Int] = {
        IO.raiseError[Int](new Exception("Boom!"))
        //IO.pure(35)
      }

      val res: Int = failedIO.recoverWith({
        case e => IO {
          logger.error("Something went wrong", e)
          42
        }
      }).unsafeRunSync()

      println {
        res
      }

      // Существует тонкое различие между вызовом ошибок внутри IO и выдачей в традиционном смысле.
      // Первый просто возвращает значение, которое кодирует сбойную программу;
      // она даст сбой только при явном запуске.
      // Последний прерывает выполнение перед возвратом какого-либо значения:

      /*
        // This always returns a value. When composed, all the subsequent IOs will fail too.
        def getUser: IO[User] = IO.raiseError(new Exception("No user found"))

        // This fails before getting a chance to return an IO.
        // It means the program will fail during its construction, not during execution
        def getUser: IO[User] = throw new Exception("No user found")
      */

      // Dыдача исключений за пределами IO, в то время как потребитель ожидает всегда получать какое-то значение,
      // сбивает с толку и опасно. Пожалуйста, не делайте этого!

    }

    def chapter6 = {
      // Давайте начнем с самого простого подхода: вызов исключений внутри IO.

      // Я начну с моделирования каждой возможной ошибки как набора объектов case,
      // каждый из которых наследует от RuntimeException.
      // Таким образом, их можно будет не только выдавать, что требуется для raiseError,
      // но и сопоставлять с образцом, что значительно облегчит нам жизнь.

      case object WrongUserName extends RuntimeException("No user with that name")
      case object WrongPassword extends RuntimeException("Wrong password")
      case class ExpiredSubscription(expirationDate: Date) extends RuntimeException("Expired subscription")
      case object BannedUser extends RuntimeException("User is banned")

      // Затем я разделил свою логику на небольшие, компонуемые программы.
      // Я оставлю реализацию на ваше усмотрение, вместо этого я хочу сосредоточиться на сигнатурах.
      // Должно быть достаточно ясно, что каждая программа должна делать.

      def findUserByName(username: String): IO[User] = IO.pure(User("коля"))
      def checkPassword(user: User, password: String): IO[Unit] = IO.pure(())
      def checkSubscription(user: User): IO[Unit] = IO.pure(())
      def checkUserStatus(user: User): IO[Unit] = IO.pure(())

      // Как только у меня появятся эти программы, я смогу составлять их с помощью flatMap.
      // Я буду использовать for-comprehension здесь,
      // потому что его легче читать, но помните, что это всего лишь синтаксический сахар для старого доброго flatMap.

      def authenticate(userName: String, password: String): IO[User] =
      for {
        user <- findUserByName(userName)
        _ <- checkPassword(user, password)
        _ <- checkSubscription(user)
        _ <- checkUserStatus(user)
      } yield user

      // Этот метод сначала пытается найти моего пользователя,
      // затем проверяет каждое бизнес-правило одно за другим
      // и, наконец, возвращает моего пользователя, если все прошло хорошо.
      // Если любая из этих промежуточных программ вызовет исключение,
      // выполнение всей композиции будет прервано,
      // а мой authenticate метод сам вернет failed IO с тем, что пошло не так.
      // Обратите внимание, что сейчас все проверки выполняются последовательно,
      // потому что так работают монады, но поскольку мы используем IO и поскольку программа,
      // скорее всего, связана с сетью, независимые проверки могут выполняться параллельно для повышения производительности.
      // Посмотрите на start/join, чтобы увидеть, как этого можно добиться.

      // Как только я соберу все свои промежуточные программы вместе,
      // я смогу вызвать свой authenticate метод и выбрать, что делать с моим пользователем.
      // В конце концов, мне также придется иметь дело с recover моими различными ошибками.

      val auth = authenticate("john.doe", "foo.bar")
        .flatMap(user => IO {
          println(s"Success! $user") })
        .recoverWith({
          case WrongUserName => IO { /* Do stuff ... */ }
          case WrongPassword => IO { /* Do stuff ... */ }
          case ExpiredSubscription(date) => IO { /* Do stuff ... */ }
          case BannedUser => IO { /* Do stuff ... */ }
          case _ => IO {
            println("Another exception was caught !") }
        })

      // Это работает, однако этот подход в корне ошибочен.
      // Ошибки нигде не появляются в сигнатуре метода authenticate,
      // что делает невозможным узнать о них без некоторых знаний о реализации.
      // Мы решили часть отслеживания эффекта, выявив наличие побочных эффектов с помощью IO,
      // это улучшение, но нам все равно придется явно документировать ошибки,
      // как если бы мы выбрасывали исключения и перехватывали их.

      // Помните, что при объединении IOs в более крупную программу возникающие исключения распространяются на всю композицию,
      // что делает их почти такими же опасными, как и обычные throws.

      // Есть еще одна проблема с этим:
      // поскольку IO  из Cats Effect может только поднимать и восстанавливать потомков типа Throwable,
      // нет способа узнать наверняка, что я поймал все свои бизнес-ошибки,
      // потому что мы не можем выполнить исчерпывающее сопоставление с образцом на Throwable.
      // Вот почему мне приходится добавлять final case _ =>
      // в свое выражение сопоставления с образцом ради исчерпывающей полноты.
      // Но затем, если я восстановлю все исключения, как я могу знать, что я правильно обработал все свои бизнес-ошибки,
      // и что ни одна из них не будет соответствовать моей окончательной ветке catch-all ?

      // - Я хочу, чтобы мои ошибки были четко видны в сигнатуре моих методов,
      // чтобы мне не приходилось так много знать о реализации.

      // - Я хочу обрабатывать каждую ошибку отдельно, чтобы давать пользователям действенную обратную связь.

      // - Я хочу, чтобы компилятор сообщал мне, когда я забываю обработать ошибку.

      // Другими словами, я хочу, чтобы моя обработка ошибок была действительно типобезопасной.
      // Мы рассмотрим все эти проблемы через минуту, но сначала я хотел бы кое-что прояснить.

      // Ошибки как граждане вашего домена

      // До сих пор мы рассматривали ошибки так, как будто они относятся к единой категории.
      // Однако на практике нам приходится отличать технические сбои от пограничных случаев в бизнесе.
      // Позвольте мне привести несколько примеров.

      // Многое может пойти не так при аутентификации пользователя, например, пользователь может не существовать,
      // или база данных может быть недоступна в это конкретное время.
      // Первый сценарий хорошо определен как часть вашей бизнес-логики: ожидается, что пользователи забудут свои учетные данные,
      // и они должны получить соответствующую обратную связь, чтобы направить их,
      // например, подсказки к процедуре восстановления учетных данных.
      // С другой стороны, недоступный компонент — это чисто технический сбой,
      // который не имеет значения ни для ваших пользователей,
      // ни для заинтересованных сторон бизнеса; но это не значит, что о нем не следует заботиться.

      // Ключевым моментом здесь является то, что бизнес-ошибки должны обеспечивать действенную обратную связь
      // для ваших пользователей, тогда как технические ошибки полностью непрозрачны для них,
      // но требуют быстрого реагирования от вашей команды.
      // Ожидается, что пограничные бизнес-случаи будут происходить в течение обычного жизненного цикла вашего приложения
      // и должны рассматриваться как первоклассные граждане доменной модели.
      // Технические сбои, с другой стороны, не должны происходить и должны рассматриваться в соответствии с их серьезностью.

      // Примерами таких технических сбоев являются сбои в работе сети, неправильная настройка приложения,
      // нехватка хранилища на сервере и т. д.
      // Правильно определенная стратегия обработки ошибок должна иметь способ их моделирования.

      // Подождите-ка, мы уже знаем, как это моделировать! Пришло время вернуть нашего старого друга Exception.
      // Действительно, исключения являются идеальным кандидатом для этого.
      // Они могут быть вызваны и восстановлены внутри IO (или, как мы выясним позже, любого типа ,
      // для которого определен F какой-либо экземпляр MonadError[F, Throwable]),
      // они уже используются подавляющим большинством библиотек, и JVM уже определяет несколько типов исключений на выбор,
      // таких как IOExceptionи TimeoutException.
      // Самое главное, исключения дадут нам некоторую трассировку стека для работы;
      // помните, что вы здесь ориентируетесь на свою команду, а не на конечных пользователей.

      // Вот почему мы изначально отказались от исключений: большая часть вреда, который они наносят приложениям
      // (и их разработчикам), возникает из-за того, что их часто используют слишком часто, что не означает, что они бесполезны.

      // Исключения хороши, когда используются для моделирования, ну, исключительного поведения.
      // Ошибкой было бы использовать их для моделирования повседневного поведения вашего приложения.
      // Когда вы используете их таким образом, тот факт, что исключения естественным образом распространяются
      // по слоям вашего приложения или, в случае с IO вашей композицией, может быть даже желательным.
      // Конечно, мы не хотим, чтобы наше приложение зависло, но когда это должно произойти, всегда желательно,
      // чтобы оно зависло быстро.
      // В эпоху микросервисов и постоянно перезапускающихся контейнеров полная остановка вашего приложения
      // может быть лучшим способом справиться с серьезным сбоем.

      // Вот как я это вижу:

      // - Каждое приложение должно иметь два отдельных канала ошибок для обработки как технических сбоев,
      // так и пограничных случаев бизнеса. Первый из них направлен на вас и ваших коллег,
      // второй — на ваших конечных пользователей.
      // - Сигнатуры типов всегда должны раскрывать как можно больше,
      // чтобы компилятор мог выполнять свою работу по оказанию нам помощи должным образом.
      // Это также уменьшает объем документации, необходимой для понимания кода, и снижает риски ошибок.
      // Это подразумевает надлежащее отслеживание побочных эффектов по причинам, которые мы видели ранее,
      // но также и то, что типы наших бизнес-ошибок должны также отображаться в сигнатурах
      // - Компилятор должен заставить нас правильно обрабатывать каждый пограничный случай бизнеса,
      // что подразумевает их моделирование таким образом, чтобы обеспечить возможность проверки на полноту.
      // - Технические сбои обычно обрабатываются один раз, на верхних уровнях приложения.

      // Давайте посмотрим, как можно достичь этих целей с помощью Scala и Cats.

    }

    def chapter7 = {
      // Сложность комбинирования эффектов
      // Вспомним, как монады используются для кодирования некоторого функционального эффекта.
      // Мы видели ранее, что IO, например, использовался для обозначения наличия побочных эффектов
      // и моделирования асинхронных операций.
      // Если бы мы хотели смоделировать вычисление, которое может завершиться ошибкой с определенным значением в качестве ошибки,
      // мы бы использовали Either вместо этого и использовали первый параметр типа для описания нашего типа ошибки.

      // Но что, если мы хотим смоделировать вычисление, как в нашем authenticate примере,
      // которое является и асинхронным, и подверженным ошибкам?
      // Этот очень распространенный вариант использования требует некоторой комбинации эффектов:
      // асинхронная часть будет предоставлено Cats Effect's IO,
      // в то время как часть обработки ошибок будет предоставлено стандартным Either.
      // Один из способов объединения этих структур — вложить их.
      // authenticate Метод из более раннего примера тогда будет определен как



      def authenticate(
                        userName: String,
                        password: String
                      ): IO[Either[AuthenticationError, User]] = ???

      // где AuthenticationError- тип суммы всех моих возможных ошибок
      // Look, no more RuntimeException here!

      sealed trait AuthenticationError
      case object WrongUserName extends AuthenticationError
      case object WrongPassword extends AuthenticationError
      final case class ExpiredSubscription(expirationDate: Date) extends AuthenticationError
      case object BannedUser extends AuthenticationError

      // Это здорово, потому что теперь не только побочные эффекты и ошибки аутентификации появляются в сигнатурах типов,
      // у нас по-прежнему есть выделенный неявный канал ошибок для технических ошибок, предоставляемый IO.
      // Это позволило бы нам в контексте веб-приложения иметь глобальный обработчик всех технических ошибок,
      // который всегда возвращает 500 Internal Error пользователям и регистрирует исключения
      // (это, по сути, то, что Http4s делает по умолчанию);
      // и в дополнение к этому глобальному обработчику компилятор
      // заставил бы нас обрабатывать все бизнес-ошибки должным образом.
      // Исчерпывающая эффективность нашей стратегии обработки ошибок гарантируется использованием запечатанных типов.

      // К сожалению, хотя этот подход и удовлетворяет многим требованиям, он обходится дорого.
      // Мы больше не можем выразить наш метод authenticate в терминах меньших специализированных программ,
      // поскольку вложенные монады не так хорошо компонуются, как монады по отдельности.
      // Возникает соблазн написать что-то вроде этого:

      /*
        def findUserByName(username: String): IO[Either[AuthenticationError, User]] = ???
        def checkPassword(user: User, password: String): IO[Either[AuthenticationError, Unit]] = ???
        def checkSubscription(user: User): IO[Either[AuthenticationError, Unit]] = ???
        def checkUserStatus(user: User): IO[Either[AuthenticationError, Unit]] = ???

        def authenticate(userName: String, password: String): IO[Either[AuthenticationError, User]] =
          for {
            user <- findUserByName(userName)
            _ <- checkPassword(user, password)
            _ <- checkSubscription(user)
            _ <- checkUserStatus(user)
          } yield user
       */

      // но он не скомпилируется. Причина этого в том, что когда у вас есть две вложенные монады,
      // это не обязательно означает, что вы можете определить одну монаду из них.
      // Не существует универсального способа определения одной монады из двух произвольных монад.
      // Нужно предоставить инструкции о том, как составить любую внешнюю монаду для каждой конкретной внутренней монады,
      // которую они хотят использовать.
      // Эти инструкции предоставляются структурой, называемой monad transformer,
      // конструктором типа, который принимает две монады в качестве аргументов и возвращает одну.

      // Без такого преобразователя для составления наших программ нам пришлось бы сначала flatMap ( IO внешнюю монаду),
      // а затем, внутри нее, flatMap внутреннюю монаду, что привело бы к коду,
      // который было бы очень трудно читать и поддерживать:

      /*
      def authenticate(userName: String, password: String): IO[Either[AuthenticationError, User]] =
        findUserByName(userName).flatMap({
          case Right(user) => checkPassword(user, password).flatMap({
            case Right(_) => checkSubscription(user).flatMap({
              case Right(_) => checkUserStatus(user).map(_.as(user))
              case Left(err) => IO.pure(Left(err))
            })
            case Left(err) => IO.pure(Left(err))
          })
          case Left(err) => IO.pure(Left(err))
        })
       */

      // К счастью, можно не только определить монадный трансформатор для Either,
      // Cats уже предоставляет его нам!

    }

    def chapter8 = {
      // Комбинирование эффектов с помощью монадных трансформаторов

      //Трансформатор EitherT — один из нескольких монадных трансформаторов, готовых к использованию в Cats.
      // EitherT[F[_], A, B] — это легкая обертка вокруг F[Either[A, B]], где F[_] может быть любая монада, которую вы хотите.
      // Мы говорим, что монадные трансформаторы — это конструкторы типов, которые принимают монады в качестве аргументов
      // и возвращают монады, просто потому, что, пока a F[_] является законной монадой,
      // полностью сконструированный EitherT[F[_], A, B] тип также будет законной монадой.

      // Эффективно монадные преобразователи позволяют нам обогащать монаду, в этом случае IO[_],
      // эффектом, описанным другой монадой, здесь Either[A, _], таким образом,
      // чтобы сохранить возможность составлять вычисления вместе.
      // Используя EitherT на IO, мы эффективно получаем возможности приостановки побочных эффектов
      // и асинхронного программирования IO, с возможностями моделирования ошибок Either.

      //  Существует двунаправленное преобразование между IO[Either[A, B]] и EitherT[IO, A, B]:

      sealed trait AuthenticationError
      case object WrongUserName extends AuthenticationError
      case object WrongPassword extends AuthenticationError
      final case class ExpiredSubscription(expirationDate: Date) extends AuthenticationError
      case object BannedUser extends AuthenticationError


      import cats.data.EitherT

      val user: IO[Either[AuthenticationError, User]] = IO.pure(Left(WrongUserName))

      // use EitherT.apply to lift a nested Either to an EitherT
      val myEitherT: EitherT[IO, AuthenticationError, User] = EitherT(user)

      // use .value to demote the EitherT to a nested monad again
      val userAgain: IO[Either[AuthenticationError, User]] = myEitherT.value

      // И теперь, когда мы знаем о EitherT, мы можем использовать его для повторной сборки нашего метода authenticate:

      def findUserByName(username: String): IO[Either[AuthenticationError, User]] = user
      def checkPassword(user: User, password: String): IO[Either[AuthenticationError, Unit]] = IO.pure(Right(()))
      def checkSubscription(user: User): IO[Either[AuthenticationError, Unit]] = IO.pure(Right(()))
      def checkUserStatus(user: User): IO[Either[AuthenticationError, Unit]] = IO.pure(Right(()))
      def authenticate(userName: String, password: String): EitherT[IO, AuthenticationError, User] =
        for {
          user <- EitherT(findUserByName(userName))
          _ <- EitherT(checkPassword(user, password))
          _ <- EitherT(checkSubscription(user))
          _ <- EitherT(checkUserStatus(user))
        } yield user

      //Если какой-либо из них EitherT содержит Left, вычисление остановится, а результат authenticate
      // самого метода также будет содержать Left. Более того, если какой-либо IO из них вызовет ошибку,
      // вычисление также остановится, и значение результирующего EitherT,
      // фактически также будет failed IO.
      //
      // Следовательно, у нас есть структура с двумя различными каналами ошибок
      // и двойной короткозамыкающей логикой.
      // Мы можем объединить EitherT вместе, и вычисление всегда будет возвращать первую обнаруженную ошибку,
      // шаблон, иногда описываемый как железнодорожно-ориентированное программирование

      // Ошибки аутентификации, которые являются неотъемлемой частью домена,
      // четко отображаются в сигнатуре типа, наряду с наличием побочных эффектов,
      // обозначенных как IO, и с ними необходимо явно работать.
      // Поскольку AuthenticationError это запечатанный тип, компилятор сообщит мне,
      // если я забуду правильно обработать ошибку аутентификации:

      /*
        val auth = authenticate("", "").value.flatMap({
          case Right(user) => IO(println(user))
          case Left(BannedUser) => IO(println(s"Error! The user is banned"))
          case Left(WrongPassword) => IO(println(s"Error! Wrong password"))
        })

          match may not be exhaustive.
          It would fail on the following inputs: Left(ExpiredSubscription(_)), Left(WrongUserName)
          val auth = authenticate("", "").value.flatMap({
      */

      // Интересно, как это EitherT работает?

      // Реализация правильно flatMap описывает EitherT логику короткого замыкания между EitherT[F, A, B]
      // и зависимой B => EitherT[F, A, C] функцией, которую я назову next EitherT .
      // Она делает ровно то, что мы делали ранее: сначала объединяет внешний IO, а затем сопоставляет внутренний Either.
      // Если значение внутри первого IO равно a Right, мы можем продолжить вычисление, применяя любое значение,
      // найденное внутри него, Right к следующему EitherT ; если это a Left, мы останавливаем вычисление,
      // поднимая его Left внутри  F[_], и next EitherT никогда не оценивается.

      // defined on cats.data.EitherT

      /*
        def flatMap[AA >: A, D](f: B => EitherT[F, AA, D])(implicit F: Monad[F]): EitherT[F, AA, D] =
          EitherT(F.flatMap(value) {
            case l @ Left(_) => F.pure(l.asInstanceOf[Either[AA, D]])
            case Right(b)    => f(b).value
          })
      */

      // EitherT позволяет нам реализовать надежную, типобезопасную стратегию обработки ошибок,
      // сохраняя при этом относительную простоту реализации.

      // - Побочные эффекты отслеживаются должным образом
      // - Ошибки в бизнесе больше не являются невидимыми, вместо этого они рассматриваются как полноправные граждане домена.
      // - У нас есть отдельный канал ошибок для чисто технических сбоев, чтобы они не загрязняли нашу логику домена.
      // - Компилятор Scala может заставить нас обрабатывать каждую бизнес-ошибку, уменьшая вероятность появления ошибок в приложении.
      // - В целом, мы умеем быстро устранять технические неполадки и легко даем полезные рекомендации нашим пользователям, если они не используют наше приложение по назначению.

      // Вдобавок ко всему, я не упомянул некоторые другие очень полезные характеристики EitherT,
      // такие как возможность построить EitherT[F, A, B] из Option[B], или даже F[Option[B]],
      // или возможность построить EitherT из булевого значения с помощью EitherT.cond.
      // В целом EitherT это очень мощная структура, обеспечивающая очень чистый и элегантный подход к управлению ошибками.

      // Однако не все так гладко в мире монадных преобразователей, и все еще существуют некоторые проблемы,
      // которые, в зависимости от создаваемого вами приложения, могут потребовать решения.

      // Первая из этих проблем — производительность.
      // Трансформаторы монад в Scala довольно медленные, гораздо медленнее, чем их аналоги в Haskell.
      // Я никогда не считал это большой проблемой, и я думаю, что это не будет большой проблемой для большинства приложений,
      // поскольку есть много других потенциальных узких мест, которые нужно устранить,
      // прежде чем пытаться уменьшить количество трансформеров монад.
      // Для приложений, ограниченных вводом-выводом, накладные расходы трансформеров монад в основном не имеют значения ;
      // для приложений, ограниченных процессором, ваш пробег может отличаться.

      // Вторая проблема с монадными трансформаторами возникает, когда вы пытаетесь сложить их вместе.
      // Ранее мы говорили, что монады использовались для описания некоторого эффекта,
      // и что монадные трансформаторы использовались для, своего рода, обогащения существующей монады эффектом,
      // описанным другой монадой, что фактически приводило к структуре, которая объединяет оба эффекта,
      // сохраняя при этом возможность цепочек вычислений (т. е. монадическую структуру как таковую).
      // С этим пониманием имеет смысл попытаться использовать более одного трансформатора одновременно:
      // что, если я хочу этот эффект и тот эффект одновременно?
      // Теоретически вы могли бы, например, сложить вместе a ReaderT, EitherT и  IO,
      // чтобы создать новую монаду, которая имеет:

      // - возможность считывать значения из некоторого контекста, доступного только для чтения (описывается ReaderT)
      // - возможность короткого замыкания с использованием любого произвольного типа в качестве типа ошибки (описывается EitherT)
      // - приостановление побочных эффектов, предоставляемых IO

      // Однако на практике стекирование монадных трансформеров в Scala требует шокирующего количества шаблонного кода,
      // что приводит разработчиков к мысли, что, возможно, им следует вообще отказаться от монадных трансформеров
      // и вернуться к вызову исключений. Взгляните на следующий код:


      // Retrieves document from a super secure data store

      /*
      def getDocument: IO[SecretDocument] = ???

      def destroyDocument: IO[Unit] = IO.unit


      type Count = Int
      val readSecretDocument: User => EitherT[IO, String, SecretDocument] = {
        val state: StateT[ReaderT[IO, User, *], Count, Either[String, SecretDocument]] =
          StateT[ReaderT[IO, User, *], Int, Either[String, SecretDocument]](currentAttemptsCount =>
            ReaderT[IO, User, (Count, Either[String, SecretDocument])](user =>
              if (currentAttemptsCount >= 3)
                destroyDocument.as((currentAttemptsCount, Left("Max attempts exceeded")))
              else if (user.isAdmin) getDocument.map(doc => (currentAttemptsCount, Right(doc)))
              else IO.pure((currentAttemptsCount + 1, Left("Access denied")))
            )
          )

        state.run(0).map(_._2).mapF(EitherT(_)).run
      }

      */

      // Это определяет функцию, которая, учитывая пользователя, может или не может предоставить доступ
      // к некоторому секретному документу, основываясь на некоторых простых правилах.
      // Чтобы получить доступ к документу, пользователь должен быть администратором.
      // Каждый раз, когда неавторизованный человек пытается получить доступ к документу, мы увеличиваем счетчик.
      // После 3 неудачных попыток документ уничтожается.
      // Эта конкретная реализация использует сложенные монадные трансформаторы и является чисто функциональной™

      // - Он использует IO, потому что наше сверхзащищенное хранилище данных является асинхронным,
      // и уничтожение документа является побочным эффектом
      // - Он использует EitherT для своих возможностей обработки ошибок
      // Он использует StateT для моделирования изменчивого состояния наших попыток противодействия

      // Но это также совершенно непонятно, особенно учитывая,
      // насколько простой должна быть реализация такого варианта использования.
      // Основная причина этого чрезмерного количества шаблонов — это количество параметров типа,
      // с которыми приходится иметь дело компилятору: система вывода типов Scala не справляется с вложенными трансформаторами,
      // заставляя вас предоставлять каждый тип отдельно.

      // Код, подобный этому, помогает нам понять, почему некоторые сторонники функционального программирования
      // иногда не продвигают преимущества функциональной парадигмы за пределами своего круга:
      // чистота такого кода просто не стоит компромисса в виде почти нечитаемой реализации.
      // Люди, которые практикуют ФП в течение длительного времени, знают, как это позволяет им делать то,
      // что делает большинство императивных языков, более безопасным способом, но также с меньшим количеством шаблонов;
      // тем не менее, это пример чего-то, что совершенно просто в императивном программировании и,
      // к сожалению, запутанно при использовании монадных трансформаторов.

      // Очевидно, что нам нужно сделать что-то лучшее.

      // Чтобы достичь цели элегантного наложения функциональных эффектов, я представлю библиотеку Cats MTL;
      // но перед этим нам нужно сделать небольшое отступление, чтобы объяснить, как эти эффекты кодируются в Scala.
      // Это поможет нам лучше понять примеры Cats MTL.


    }

    def chapter9 = {
      // Короткое отступление: классы типов и полиморфизм ad hoc

      // Полиморфизм ad hoc — это общая концепция для описания методов, которые работают с различными конкретными типами.
      // Один из способов, которым мы можем достичь этого вида полиморфизма в Scala, —
      // это объединение параметров типа ( generics ) и классов типа.

      // Мы используем неявные параметры или контекстные границы
      // (последнее — просто синтаксический сахар для первого) для определения ограничений на параметры типа.
      // Эти ограничения ограничивают конкретные структуры, к которым мы можем применять методы,
      // в то же время позволяя нам использовать преимущества требуемых контрактов.

      // Рассмотрим следующие методы:

     /*
           def combineHeaders(a: Headers, b: Headers): Headers =
              // Some complex combination logic
              ???

            def combineAllHeaders(list: List[Headers]): Headers =
              list.foldLeft(Headers.empty)(combineHeaders)

     */

      // Использование конкретных структур требует от нас не только определения методов
      // с разными именами для каждой конкретной структуры, которую мы хотим объединить,
      // но и переопределения combineAll метода каждый раз;
      // не говоря уже о том, что если бы мы захотели использовать что-то другое, а не a List, например a Vector или  Set,
      // нам пришлось бы также определить специализированные версии метода combineAll.

      // Вместо этого классы типов позволяют нам написать что-то вроде этого:

      import cats._
      import cats.implicits._

      def combineAll[F[_]: Foldable, A: Monoid](f: F[A]) = f.foldLeft(Monoid[A].empty)(Monoid[A].combine)

      // Метод combineAll в этом примере определен не только для конкретных структур, таких как List и Headers,
      // но и для любой структуры F[_], которая может быть свернута, и любого типа A, значения которого могут быть объединены.
      // Monoid класс типов из Cats описывает типы, которые имеют ассоциативную бинарную операцию и пустой элемент;
      // любой тип, реализующий этот контракт, может извлечь выгоду из combineAll метода.

      // Я более подробно рассмотрел классы типов в другой статье.
      // Cats MTL полностью полагается на концепцию классов типов в своей работе,
      // поэтому обязательно ознакомьтесь с этой концепцией, прежде чем приступать к следующему.
      // https://guillaumebogard.dev/posts/typeclasses/


      // Знакомство с Cats MTL

      // Вот мы и подошли к концу статьи, которая, как я теперь думаю, могла бы выиграть от разделения на множество частей.
      // Если вы дошли до этого места, спасибо! Мы рассмотрели отслеживание эффектов, типобезопасную обработку ошибок,
      // технические ошибки против ошибок домена, монады, вложенные монады, преобразователи монад и
      // даже вложенные преобразователи монад.
      // Теперь пришло время развить все, что мы узнали до сих пор, чтобы достичь окончательной версии
      // нашего варианта использования аутентификации.

      // Мы будем использовать Cats MTL
      // https://typelevel.org/cats-mtl/getting-started.html
      // — библиотеку, которая объединяет монадные преобразователи с классами типов таким образом,
      // чтобы упростить объединение множества преобразователей в один.

      // Идея Cats MTL относительно проста:
      // монадные преобразователи используются для добавления эффекта монады к другой монаде,
      // а Cats MTL кодирует эффекты наиболее распространенных монадных преобразователей
      // ( OptionT, EitherT, ReaderT, WriterT, StateTи IorT) с помощью классов типов.
      // Когда вам требуется много таких классов типов, используя контекстные границы или неявные параметры,
      // как мы видели ранее, вы фактически объединяете монадные преобразователи вместе;
      // но поскольку вы делаете это через дополнительный уровень абстракции,
      // вам не нужно иметь дело с болезненными проблемами вывода типов, с которыми мы сталкивались ранее.




      sealed trait AuthenticationError
      case object WrongUserName extends AuthenticationError
      case object WrongPassword extends AuthenticationError
      final case class ExpiredSubscription(expirationDate: Date) extends AuthenticationError
      case object BannedUser extends AuthenticationError

      // Raising errors

      // В Cats MTL Raise[F[_], E] класс типа используется для предоставления некоторой структуры F[_]
      // с возможностью вызывать ошибки типа E.
      // Мы можем использовать его для написания метода проверки пароля,
      // который вызывает ошибки типа AuthenticationError:


      /*

      def checkPassword[F[_]](user: User, password: String)(
        implicit FR: Raise[F, AuthenticationError],
        A: Applicative[F]) : F[Unit] =
        if (password == "1234") A.unit else FR.raise(WrongPassword)

        */

      // Обратите внимание, что требование Raise подразумевает, что Functor может быть определено для F,
      // то есть мы можем отображать F[_] значения без явного требования к классу типа Functor.
      // Applicative требуется для построения «нейтрального» F[Unit] значения,
      // поскольку unit метод определен для аппликационных функторов, а не для обычных функторов.

      // Восстановление

      // Класс Handle[F[_], E] типа, также из Cats MTL, расширяется Raise[F[_], E] возможностью F[_]
      // восстановления значений типа E. Он также подразумевает экземпляр Applicative[F].



      /*

      def runAndLogErrors[F[_], A, E](program: => F[A])(
      implicit logger: E => F[Unit],
      AH: Handle[F, E],
      M: Monad[F]
      ): F[A] =
      // We "catch" the error, log it, and then raise it again
        program.handleWith((e: E) => logger(e) >> e.raise[F, A])

      */

      // В этом примере нам необходимо потребовать экземпляр Monadf для F[_] чтобы иметь возможность
      // вызвать >> оператор, который позволяет нам вычислять одно монадическое значение за другим.

      // Два канала ошибок для двух типов ошибок

      // Мы можем потребовать много экземпляров классов типов,
      // чтобы получить преимущество наличия отдельных каналов ошибок для различения технических сбоев и ошибок домена;
      // в частности, мы можем объединить классы типов Raise/Handle[F, DomainError] из Cats MTL
      // и MonadError[F, TechnicalError] класс типов из ядра Cats,
      // где DomainError, скорее всего, будет запечатанный тип нашего собственного изготовления, например AuthenticationError,
      // и, TechnicalError скорее всего, будет Throwable.

      /*

      def findUserByName[F[_]](name: String)(implicit ME: MonadError[F, Throwable]
      ): F[User] =
        ME.raiseError(new RuntimeException("The database cannot be reached"))

      */

      // Handle[F, E, A] и Raise[F, E, A] являются наиболее полезными классами типов при работе с отказами.
      // Cats MTL предоставит нам экземпляры этих классов типов не только для EitherT[F, E, A]
      // (при условии F соответствия ожидаемым требованиям),
      // но и для любого стека монад-трансформеров, содержащих EitherT[F, E, A].

      // Заключительные примеры и заключение

      // Давайте посмотрим, как классы типов из Cats MTL могут быть применены к нашему authenticate методу.
      // Помните, мы хотим реализовать метод в терминах меньших специализированных программ,
      // а затем скомпоновать эти программы вместе.


      def findUserByName[F[_]](name: String)(
      implicit ME: MonadError[F, Throwable]
      ): F[User] = ME.raiseError(new RuntimeException("The database cannot be reached"))

      def checkPassword[F[_]](user: User, password: String)(
        implicit FR: Raise[F, AuthenticationError],
        A: Applicative[F]
      ): F[Unit] = if (password == "1234") A.unit else FR.raise(WrongPassword)

      def checkSubscription[F[_]](user: User): F[Unit] = ???
      def checkUserStatus[F[_]](user: User): F[Unit] = ???

      def authenticate[F[_]](userName: String, password: String)(
        // We depend on the requirements of our intermediate methods
        implicit ME: MonadError[F, Throwable],
        functorRaise: Raise[F, AuthenticationError]
      ): F[User] =
        for {
          user <- findUserByName[F](userName)
          _ <- checkPassword[F](user, password)
          _ <- checkSubscription[F](user)
          _ <- checkUserStatus[F](user)
        } yield user

      // Как и ожидалось, authenticate метод будет замыкаться на первой обнаруженной ошибке в любом из каналов ошибок.
      // Технические ошибки и ошибки домена могут быть обработаны специально,
      // с надлежащими проверками исчерпывающей проверки для последних.
      // Давайте проиллюстрируем это, смоделировав, как это может быть использовано на HTTP-сервере:

      // Let's pretend this is an HTTP server for a moment
      final case class HttpResponse(code: Int, body: String)

      def authenticateAndServeResponse[F[_]](implicit
                                             ME: MonadError[F, Throwable],
                                             AE: Handle[F, AuthenticationError],
                                             // `Sync` is the type class that describes the ability to suspend side effects
                                             // `IO` provides a concrete instance of Sync
                                             Sync: Sync[F]
                                            ): F[HttpResponse] =
        authenticate[F]("john.doe", "123456")
          // If the authentication succeeds, we return the "200 OK" status
          .map(user => HttpResponse(code = 200, body = user.toString))
          // Here we can handle business errors if we want to.
          // "handleWith" expects us to produce an [[HttpResponse]],
          // just like the [[authenticate]] method.
          .handleWith[AuthenticationError]({
            case e @ WrongUserName =>
              Sync.delay { /* Do stuff, like logging the error ... */ } as
                HttpResponse(403, "Wrong username!")
            case e @ WrongPassword =>
              Sync.delay { /* Do stuff, like logging the error ... */ } as
                HttpResponse(403, "Wrong password!")
            case e: AuthenticationError =>
              Sync.delay(println(s"Another domain error was caught ! ($e)")) as
                HttpResponse(403, e.toString)
          })
          // Here we can handle technical failures.
          // "recoverWith" expects us to produce an [[HttpResponse]]
          // Since this is a technical, server-side failure, we're going to send
          // a "500 Internal Server Error" status
          .recoverWith({
            case e: Throwable =>
              Sync.delay(println("Something went terribly wrong!")) as
                HttpResponse(500, "Something went wrong on our side, please retry later")
          })

      // Разделение ошибок таким образом полезно для реализации стратегий повтора:
      // если запрошенное действие не может быть выполнено из-за временного сбоя сети,
      // вероятно, имеет смысл повторить несколько секунд.
      // Но если ошибка возникает на стороне клиента, нам не нужна стратегия повтора,
      // нам нужно отправить надлежащую обратную связь.

      //Интерпретация программы

      // Когда придет время запустить нашу окончательную программу,
      // мы должны предоставить конкретный экземпляр для нашего F[_] типа;
      // тот, который удовлетворяет контрактам
      // MonadError[F, Throwable],
      // Handle[F, AuthenticationError] и
      // Sync[F]. Ч
      // Что такое такая структура данных?



        type F[A] = EitherT[IO, AuthenticationError, A]

        val a: F[User] = authenticate[F]("john.doe", "123456")


      // EitherT[IO, AuthenticationError, A] удовлетворяет всем этим условиям:

      // возможность приостанавливать побочные эффекты, описанные Sync классом типа,
      // и вызывать технические ошибки типа Throwable, описанные MonadError, реализованы IO
      // способность вызывать и устранять ошибки типа AuthenticationError гарантируется конкретным экземпляром
      // Handle[F, AuthenticationError], предоставленным нам Cats MTL,
      // для любого EitherT[F, AuthenticationError, A], и любого стека монад-трансформеров, содержащего последний,
      // при условии, что F имеется экземпляр Applicative(который снова предоставляется cats.effect.IO)


      // В заключение следует отметить, что монады и преобразователи монад дают нам возможность определить надежную,
      // действительно безопасную с точки зрения типов стратегию обработки ошибок,
      // а Cats MTL предоставляет нам более простой способ работы с преобразователями монад.

      // Какое бы решение вы ни выбрали, вот несколько ключевых моментов, которые следует запомнить:

      // - ошибки также являются частью вашего домена! попробуйте выявить их с помощью системы типов,
      // вместо того, чтобы зарывать их в реализацию
      // - не путайте технические ошибки с пограничными случаями домена.
      // При моделировании ошибок спросите себя:
      // «Представляет ли это какую-либо ценность для моих пользователей или имеет смысл только для меня как разработчика?»
      // - используйте запечатанные типы для кодирования ошибок, чтобы компилятор мог помочь вам обнаружить упущения
      // - монады составляются в стиле «первая ошибка побеждает».
      // - Если вам нужно накапливать ошибки, обратитесь к Validated instead.
      // Опять же, доклад Марка Канласа — отличное место для начала
      // - не злоупотребляйте исключениями
      // - FP, с его акцентом на ссылочной прозрачности, во многом посвящен сигнатурам типов, которым вы можете доверять™.
      // Монады позволяют нам объявить о наличии побочных эффектов и риске сбоя с использованием типов,
      // что значительно снижает непредвиденное поведение и, в свою очередь, удобство обслуживания ваших приложений

      // Как всегда, спасибо за прочтение этой статьи, надеюсь,
      // она помогла вам лучше понять некоторые концепции функционального программирования и то,
      // как они применяются в реальных случаях использования.
      // Этот репозиторий содержит проект Scala почти со всеми примерами из этой статьи и некоторыми другими.
      // https://github.com/gbogard/cats-mtl-talk
    }
  }
  part1.chapter1
  part1.chapter2
  part1.chapter3
  part1.chapter4
  part1.chapter5

  // Вариант использования: моделирование процесса аутентификации

  // В оставшейся части этой статьи я представлю несколько стратегий обработки ошибок,
  // подчеркнув различия в реализации этого простого варианта использования:

  // Я хочу аутентифицировать пользователя, используя имя и пароль.
  // Мой метод аутентификации вернет информацию о пользователе.
  // После того, как я нашел пользователя и убедился, что его пароль соответствует заданным входным данным,
  // мне также нужно применить несколько бизнес-правил:

  // У пользователя должна быть действующая подписка
  // (вероятно, для этого потребуется позвонить в какую-либо службу выставления счетов)
  // Пользователю не должно быть запрещено пользоваться сервисом
  // (вероятно, это принудительно осуществляется путем вызова какого-либо компонента модерации)

  //Каждый шаг процесса является потенциальным источником ошибок.
  // И поскольку есть много внешних выборок данных, IO здесь будет необходим.
  // Для каждой стратегии обработки ошибок я реализую метод аутентификации,
  // составляя небольшие программы с использованием монадической композиции.

  part1.chapter6
  part1.chapter7
  part1.chapter8
  part1.chapter9
}


